======================
The form rendering API
======================

.. versionadded:: 1.11

Django form widgets are rendered using the Django template backend system.

The form rendering process can be customized at several levels:

* Widgets can specify custom template names.
* Forms and widgets can specify custom renderer classes.
* Built-in templates can be overridden within a project or application.

.. _low-level-widget-render-api:

The low-level render API
------------------------

Widget templates are stored in the ``django/forms/widgets`` path. A project
can provide a custom template for ``input.html`` by defining
``django/forms/widgets/input.html``, for example.

The rendering of form templates is controlled by a customizable renderer class.
A custom renderer can be specified by updating the :setting:`FORM_RENDERER`
setting. It defaults to
``'django.forms.renderers.templates.DjangoTemplateRenderer'``.

.. module:: django.forms.renderers.templates

.. class:: DjangoTemplateRenderer

This renderer uses a :class:`~django.template.backends.django.DjangoTemplates`
engine. It loads templates from the application directories and the built-in
form templates directory.

.. method:: get_template(template_name)

    Given a template name, returns a :class:`~django.template.Template` object,
    or raises :exc:`~django.template.TemplateDoesNotExist`.

.. method:: render(template_name, context, request=None)

    Renders the ``template_name`` and ``context``. Calls :meth:`.get_template`
    to load the given ``template_name``.

    If you implement a custom renderer, this is the only method that Django
    calls and therefore that you must implement. :meth:`get_template` is called
    by ``DjangoTemplateRenderer.render()``, but your render doesn't need to
    follow this pattern.

If you want to use a custom template engine specifically for form rendering,
you could create your own custom renderer subclass like::

    from django.forms.renderers.templates import TemplateRenderer
    from django.utils.functional import cached_property

    class MyRenderer(TemplateRenderer):
        def get_template(self, template_name):
            return self.engine.get_template(template_name)

        @cached_property
        def engine(self):
            return Jinja2({
                'APP_DIRS': False,
                'DIRS': ['/path/to/templates/'],
                'NAME': 'djangoforms',
                'OPTIONS': {},
            })

.. class:: JinjaTemplateRenderer

This renderer is the same as :class:`DjangoTemplateRenderer` except that it
uses a :class:`~django.template.backends.jinja2.Jinja2` backend.

To use this backend, all the widgets in your project and its third-party apps
must have Jinja2 templates. You can't use this renderer, for example, if you're
using :mod:`django.contrib.admin` because Jinja2 templates aren't included for
the admin widgets.

.. class:: ProjectTemplateRenderer

This renderer gives you complete control of how widget templates are sourced.
It uses :func:`django.template.loader.get_template` to find widget
templates based on what's configured in the :setting:`TEMPLATES` setting.

Using the renderer along with the built-in widget templates requires either:

#. ``'django.forms'`` in :setting:`INSTALLED_APPS` and at least one engine
   with ``APP_DIRS=True``.

#. Adding the built-in widgets templates directory (``django/forms/templates``
   or ``django/forms/jinja2``) in ``DIRS`` of one of your template engines.

You've chosen to take full control, so it's your responsibility to make
the form templates you need can be located.

Customizing widget rendering
----------------------------

Form widgets are rendered with the Django template system. This gives you full
control of widget output.

Each widget has a ``template_name`` attribute, such as
``'django/forms/widgets/textarea.html'``. See :ref:`built-in widgets` for the
name of each widget's template.

When rendered, the template receives a context from
:meth:`.Widget.get_context`. By default, widgets receive a single value in the
context, ``widget``. This is a dictionary that contains values like:

* ``name``
* ``value``
* ``attrs``
* ``is_hidden``
* ``template_name``

Some widgets add further information to the context. For instance, all widgets
that subclass ``Input`` defines ``widget['type']`` and :class:`.MultiWidget`
defines ``widget['subwidgets']`` for looping purposes.

Overriding widget templates works the same as overriding other templates. The
:class:`ProjectTemplateRenderer` uses
:func:`~django.template.loader.get_template` to find a template.

Overriding the renderer per form
--------------------------------

You can provide a custom render by setting the :attr:`.Form.default_renderer`
attribute or by using the ``renderer`` argument of :meth:`.Widget.render`.
